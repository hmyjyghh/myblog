(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{574:function(_,v,t){"use strict";t.r(v);var l=t(17),a=Object(l.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"前端埋点上报"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端埋点上报"}},[_._v("#")]),_._v(" 前端埋点上报")]),_._v(" "),t("h3",{attrs:{id:"_1-手动代码埋点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-手动代码埋点"}},[_._v("#")]),_._v(" 1. 手动代码埋点")]),_._v(" "),t("ol",[t("li",[_._v("开发者需要手动写代码，在需要埋点的地方，调用埋点的函数，并传入参数")])]),_._v(" "),t("p",[_._v("特点：")]),_._v(" "),t("ul",[t("li",[_._v("可以很好的满足定制化的需求，自定义属性或者事件")])]),_._v(" "),t("p",[_._v("缺点")]),_._v(" "),t("ul",[t("li",[_._v("埋点代码的侵入性太强，跟业务代码耦合在一起，后期维护成本较高")])]),_._v(" "),t("h3",{attrs:{id:"_2-可视化埋点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-可视化埋点"}},[_._v("#")]),_._v(" 2. 可视化埋点")]),_._v(" "),t("p",[_._v("也叫框架式埋点 or 无痕式  埋点")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("通过一个可视化的页面，由用户对业务页面进行圈点，")])]),_._v(" "),t("li",[t("p",[_._v("在页面上的元素，按钮，链接，进行埋点的一些配置注入")])]),_._v(" "),t("li",[t("p",[_._v("通过在页面中嵌入可视化埋点SDK")])]),_._v(" "),t("li",[t("p",[_._v("SDK 上面呢，它会上报页面元素的信息到服务器")])]),_._v(" "),t("li",[t("p",[_._v("服务器呢，对页面元素进行分析，标记出可以被埋点的元素")])]),_._v(" "),t("li",[t("p",[_._v("用户在这些元素上进行标注，然后前端再统一进行渲染，可以做到按需配置，不会产生大量的无用数据")])]),_._v(" "),t("li",[t("p",[_._v("缺点：")])])]),_._v(" "),t("ol",[t("li",[_._v("比较难加载一些运行时的参数")]),_._v(" "),t("li",[_._v("当页面结构发生变化的时候，需要部分重新去配置")])]),_._v(" "),t("h3",{attrs:{id:"_3-无埋点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-无埋点"}},[_._v("#")]),_._v(" 3. 无埋点")]),_._v(" "),t("p",[_._v("也叫 自动化埋点  或者  全埋点")]),_._v(" "),t("ol",[t("li",[_._v("通过监听浏览器全局事件， 来收集用户数据的")]),_._v(" "),t("li",[_._v("页面上所有的用户点击的操作，都会被收集上报")]),_._v(" "),t("li",[_._v("与业务代码没有耦合，")]),_._v(" "),t("li",[_._v("收集的用户行为数据也比较全，但是数据量非常大，无用数据太多，增加了服务器的压力")]),_._v(" "),t("li",[_._v("也无法进行定制化的一些埋点，只能收集一些常用的基本数据")]),_._v(" "),t("li",[_._v("只能用于颗粒度比较粗的数据分析")])])])}),[],!1,null,null,null);v.default=a.exports}}]);