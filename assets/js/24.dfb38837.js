(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{422:function(t,a,s){"use strict";s.r(a);var e=s(1),_=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"前端缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端缓存"}},[t._v("#")]),t._v(" 前端缓存")]),t._v(" "),a("h3",{attrs:{id:"_1-什么是web缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是web缓存"}},[t._v("#")]),t._v(" 1. 什么是web缓存？")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("web缓存主要指的是两部分："),a("code",[t._v("浏览器缓存")]),t._v("和"),a("code",[t._v("http缓存")]),t._v("。")])]),t._v(" "),a("li",[a("p",[t._v("浏览器缓存：比如,localStorage,sessionStorage,cookie等等。这些功能主要用于缓存一些必要的数据，比如用户信息。比如需要携带到后端的参数。亦或者是一些列表数据等等。")])]),t._v(" "),a("li",[a("p",[t._v("但是 像localStorage，sessionStorage这种用户缓存数据的功能，他只能保存5M左右的数据。cookie则更少，大概只能有4kb的数据。")])])]),t._v(" "),a("p",[a("strong",[t._v("其中http缓存是web缓存的核心")])]),t._v(" "),a("p",[t._v("如果本地有缓存，则直接从本地存储，无须再从服务器读取。")]),t._v(" "),a("h3",{attrs:{id:"_2-缓存可以解决什么问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-缓存可以解决什么问题"}},[t._v("#")]),t._v(" 2. 缓存可以解决什么问题？")]),t._v(" "),a("ul",[a("li",[t._v("减少不必要的网络传输，节约宽带（就是省钱）")]),t._v(" "),a("li",[t._v("更快的加载页面（就是加速）")]),t._v(" "),a("li",[t._v("减少服务器负载，避免服务器过载的情况出现。（就是减载）")])]),t._v(" "),a("p",[t._v("但也有缺点")]),t._v(" "),a("ul",[a("li",[t._v("占内存（有些缓存会被存到内存中）")])]),t._v(" "),a("p",[t._v('日常的开发中，我们最关心的，还是"更快的加载页面"; 尤其是对于react/vue等SPA（单页面）应用来说，首屏加载是老生常谈的问题。这个时候，缓存就显得非常重要。不需要往后端请求，直接在缓存中读取。速度上，会有显著的提升。是一种提升网站性能与用户体验的有效策略。')]),t._v(" "),a("h3",{attrs:{id:"_3-http缓存包含哪几种"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-http缓存包含哪几种"}},[t._v("#")]),t._v(" 3. http缓存包含哪几种？")]),t._v(" "),a("p",[t._v("http缓存又分为"),a("code",[t._v("强制缓存")]),t._v("和"),a("code",[t._v("协商缓存")]),t._v("两种缓存,我们来深度剖析一下强制缓存和协商缓存各自的优劣以及他们的使用场景以及使用原理")]),t._v(" "),a("h3",{attrs:{id:"_4-强制缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-强制缓存"}},[t._v("#")]),t._v(" 4. 强制缓存")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("强制缓存，我们简称"),a("code",[t._v("强缓存")]),t._v("。")])]),t._v(" "),a("li",[a("p",[t._v("基于Expires字段实现的强缓存\n但"),a("code",[t._v("Expires")]),t._v("过度依赖本地时间，如果本地与服务器时间不同步，就会出现资源无法被缓存或者资源永远被缓存的情况。所以，强缓存功能通常使用"),a("code",[t._v("cache-control")]),t._v("字段来代替Expires字段。")])]),t._v(" "),a("li",[a("p",[t._v("基于Cache-control实现的强缓存")])])]),t._v(" "),a("p",[a("code",[t._v("Cache-control")]),t._v("这个字段在http1.1中被增加，"),a("code",[t._v("Cache-control")]),t._v("完美解决了"),a("code",[t._v("Expires")]),t._v("本地时间和服务器时间不同步的问题。是当下的项目中实现强缓存的最常规方法。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//往响应头中写入需要缓存的时间")]),t._v("\nres"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("writeHead")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("200")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token string-property property"}},[t._v("'Cache-Control'")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'max-age=10'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("Cache-Control:max-age=N，N就是需要缓存的秒数。从第一次请求资源的时候开始，往后N秒内，资源若再次请求，则直接从磁盘（或内存中读取），不与服务器做任何交互。")]),t._v(" "),a("p",[a("strong",[t._v("Cache-control有max-age、s-maxage、no-cache、no-store、private、public这六个属性。")])]),t._v(" "),a("ul",[a("li",[t._v("max-age决定客户端资源被缓存多久。")]),t._v(" "),a("li",[t._v("no-cache表示是强制进行协商缓存。")]),t._v(" "),a("li",[t._v("no-store是表示禁止任何缓存策略。")]),t._v(" "),a("li",[t._v("public表示资源即可以被浏览器缓存也可以被代理服务器缓存。")]),t._v(" "),a("li",[t._v("private表示资源只能被浏览器缓存。")])]),t._v(" "),a("h3",{attrs:{id:"_5-协商缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-协商缓存"}},[t._v("#")]),t._v(" 5. 协商缓存")]),t._v(" "),a("blockquote",[a("p",[t._v("基于LastModified的协商缓存")])]),t._v(" "),a("p",[t._v("基于last-modified的协商缓存实现方式是:")]),t._v(" "),a("ol",[a("li",[t._v("首先需要在服务器端读出文件修改时间，")]),t._v(" "),a("li",[t._v("将读出来的修改时间赋给响应头的last-modified字段。")]),t._v(" "),a("li",[t._v("最后设置Cache-control:no-cache")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" fs "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'fs'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" mtime "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" fs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("statSync")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./bg.png'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 读取修改时间")]),t._v("\n\nres"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setHeader")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'last-modified'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" mtime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("toUTCString")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置文件最后修改时间")]),t._v("\nres"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setHeader")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Cache-Control'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'no-cache'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Cache-control:no-cache的意思是跳过强缓存校验，直接进行协商缓存。")]),t._v("\n")])])]),a("p",[t._v("当客户端读取到"),a("code",[t._v("last-modified")]),t._v("的时候，会在下次的请求标头中携带一个字段:"),a("code",[t._v("If-Modified-Since")]),t._v("。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/myblog/images/cache_20230228.png",alt:"cache"}})]),t._v(" "),a("p",[t._v("而这个请求头中的If-Modified-Since就是服务器第一次修改时候给他的时间，也就是上图中的")]),t._v(" "),a("p",[t._v("res.setHeader('last-modified', mtime.toUTCString())")]),t._v(" "),a("p",[t._v("这一行。")]),t._v(" "),a("p",[t._v("那么之后每次对该资源的请求，都会带上If-Modified-Since这个字段，而服务端就需要拿到这个时间并再次读取该资源的修改时间，让他们两个做一个比对来决定是读取缓存还是返回新的资源。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/myblog/images/cache_20230228141352.jpg",alt:"cache"}})]),t._v(" "),a("ul",[a("li",[t._v("用一张图来解释下协商缓存\n"),a("img",{attrs:{src:"/myblog/images/cache_20230228141528.png",alt:"cache"}})])]),t._v(" "),a("p",[t._v("使用以上方式的协商缓存已经存在两个非常明显的漏洞。这两个漏洞都是基于文件是通过比较修改时间来判断是否更改而产生的。")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("因为是更具文件修改时间来判断的，所以，在文件内容本身不修改的情况下，依然有可能更新文件修改时间（比如修改文件名再改回来），这样，就有可能文件内容明明没有修改，但是缓存依然失效了。")])]),t._v(" "),a("li",[a("p",[t._v("当文件在极短时间内完成修改的时候（比如几百毫秒）。因为文件修改时间记录的最小单位是秒，所以，如果文件在几百毫秒内完成修改的话，文件修改时间不会改变，这样，即使文件内容修改了，依然不会 返回新的文件。")])])]),t._v(" "),a("p",[t._v("为了解决上述的这两个问题。从http1.1开始新增了一个头信息，ETag(Entity 实体标签)")]),t._v(" "),a("blockquote",[a("p",[t._v("基于ETag的协商缓存")])]),t._v(" "),a("p",[a("code",[t._v("ETag")]),t._v("就是将原先协商缓存的比较时间戳的形式修改成了比较文件指纹。")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("第一次请求某资源的时候，服务端读取文件并计算出文件指纹，将文件指纹放在响应头的etag字段中跟资源一起返回给客户端。")])]),t._v(" "),a("li",[a("p",[t._v("第二次请求某资源的时候，客户端自动从缓存中读取出上一次服务端返回的ETag也就是文件指纹。并赋给请求头的if-None-Match字段，让上一次的文件指纹跟随请求一起回到服务端。")])]),t._v(" "),a("li",[a("p",[t._v("服务端拿到请求头中的is-None-Match字段值（也就是上一次的文件指纹），并再次读取目标资源并生成文件指纹，两个指纹做对比。如果两个文件指纹完全吻合，说明文件没有被改变，则直接返回304状态码和一个空的响应体并return。如果两个文件指纹不吻合，则说明文件被更改，那么将新的文件指纹重新存储到响应头的ETag中并返回给客户端")])])]),t._v(" "),a("ul",[a("li",[t._v("用一张图来解释下ETag协商缓存\n"),a("img",{attrs:{src:"/myblog/images/cache_20230228142105_etag.png",alt:"cache"}})])]),t._v(" "),a("p",[a("strong",[t._v("从校验流程上来说，协商缓存的修改时间比对和文件指纹比对，几乎是一样的。")])]),t._v(" "),a("ul",[a("li",[t._v("值得注意的一点是，不同于"),a("code",[t._v("cache-control")]),t._v("是"),a("code",[t._v("expires")]),t._v("的完全替代方案。"),a("code",[t._v("ETag")]),t._v("并不是"),a("code",[t._v("last-modified")]),t._v("的完全替代方案。而是last-modified的补充方案。")])]),t._v(" "),a("h3",{attrs:{id:"_6-如何设置缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-如何设置缓存"}},[t._v("#")]),t._v(" 6. 如何设置缓存?")]),t._v(" "),a("p",[t._v("从前端的角度来说:")]),t._v(" "),a("p",[t._v("你什么都不用干，缓存是缓存在前端，但实际上代码是后端的同学来写的。如果你需要实现前端缓存的话啊，通知后端的同学加响应头就好了。")]),t._v(" "),a("h3",{attrs:{id:"_7-哪些文件对应哪些缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-哪些文件对应哪些缓存"}},[t._v("#")]),t._v(" 7. 哪些文件对应哪些缓存?")]),t._v(" "),a("ul",[a("li",[t._v("有哈希值的文件设置强缓存即可。没有哈希值的文件（比如index.html）设置协商缓存")])]),t._v(" "),a("p",[a("img",{attrs:{src:"/myblog/images/cache_20230228142828.png",alt:"cache"}})]),t._v(" "),a("p",[t._v("这是我打完包之后的css文件。大家是否注意到。我划了红线的部分。明显，这绝不是我的文件名。这串和乱码一样的字符串叫"),a("code",[t._v("哈希值")]),t._v("。每次打包之后都会生产一串新的哈希值并追加到我们的文件名中。"),a("code",[t._v("哈希值")]),t._v("是打包后的文件名的一部分。")]),t._v(" "),a("h3",{attrs:{id:"_8-总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-总结"}},[t._v("#")]),t._v(" 8. 总结")]),t._v(" "),a("ul",[a("li",[t._v("http缓存可以减少宽带流量，加快响应速度。")]),t._v(" "),a("li",[t._v("关于强缓存，"),a("code",[t._v("cache-control")]),t._v("是"),a("code",[t._v("Expires")]),t._v("的完全替代方案，在可以使用"),a("code",[t._v("cache-control")]),t._v("的情况下不要使用"),a("code",[t._v("expires")])]),t._v(" "),a("li",[t._v("关于协商缓存,"),a("code",[t._v("etag")]),t._v("并不是"),a("code",[t._v("last-modified")]),t._v("的完全替代方案，而是补充方案，具体用哪一个，取决于业务场景。")]),t._v(" "),a("li",[t._v("有些缓存是从磁盘读取，有些缓存是从内存读取，有什么区别？答：从内存读取的缓存更快。")]),t._v(" "),a("li",[t._v("所有带304的资源都是协商缓存，所有标注（从内存中读取/从磁盘中读取）的资源都是强缓存。")])]),t._v(" "),a("h3",{attrs:{id:"_9-最后再附上一张http缓存流程图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-最后再附上一张http缓存流程图"}},[t._v("#")]),t._v(" 9. 最后再附上一张http缓存流程图")]),t._v(" "),a("p",[a("img",{attrs:{src:"/myblog/images/cache.png",alt:"cache"}})])])}),[],!1,null,null,null);a.default=_.exports}}]);