(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{531:function(t,a,s){"use strict";s.r(a);var n=s(3),_=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-关于zustand"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-关于zustand"}},[t._v("#")]),t._v(" 1. 关于zustand")]),t._v(" "),a("p",[t._v("zustand 在 React 社区中变得越来越流行。")]),t._v(" "),a("p",[t._v("这是因为它提供了一种现代、轻量级的状态管理解决方案，与传统的 React 状态管理库相比，它具有以下一些优势，这些优势可能使其变得更加受欢迎：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("极简的API: zustand 提供了一个非常简单而直观的API，不需要大量的模板代码或复杂的配置。这使得开发者能够更快速地设置和使用状态。")])]),t._v(" "),a("li",[a("p",[t._v("小巧和高性能: zustand 的核心库非常小巧，不会增加项目的打包大小，同时性能出色。它使用原生的 Proxy 对象来实现状态变更的追踪，这使得它非常高效。")])]),t._v(" "),a("li",[a("p",[t._v("使用Hook API: zustand 基于 React 的 Hook API ，这意味着你可以在函数式组件中直接使用它，而不需要编写类组件或 HOC（高阶组件）。")])]),t._v(" "),a("li",[a("p",[t._v("自动订阅和更新: zustand 自动处理了状态订阅和更新的问题，你不需要手动调用 setState 或其他类似的方法来通知组件状态的变化。")])]),t._v(" "),a("li",[a("p",[t._v("支持原生的Immer: zustand 与 Immer 库结合得非常好，Immer 使得不可变数据操作更加容易，同时 zustand 可以自动检测到 Immer 的更改并更新状态。")])]),t._v(" "),a("li",[a("p",[t._v("优秀的社区支持: zustand 拥有一个积极的社区，有很多用户贡献了开源的插件和扩展，可以帮助你处理更复杂的状态管理需求。")])]),t._v(" "),a("li",[a("p",[t._v("零依赖性: zustand 本身没有依赖，不需要引入其他的库或工具。这使得它在项目中的集成非常简单。")])]),t._v(" "),a("li",[a("p",[t._v("服务器渲染支持: zustand 对于服务器渲染（SSR）也提供了很好的支持。")])])]),t._v(" "),a("p",[t._v("需要注意的是，流行的状态管理库可能会随着时间的推移发生变化，新的库可能出现，而旧的库可能不再维护。因此，要了解当前的趋势和最新的状态管理库，最好查看 React 社区和相关资源以获取最新的信息。无论如何，zustand 是一个有吸引力的状态管理库，适用于许多 React 项目。")])])}),[],!1,null,null,null);a.default=_.exports}}]);